<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Imaginâˆ Lab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/examples/jsm/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <style>
    :root {
      --bg-color: #000000;
      --accent: #38bdf8;
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: var(--bg-color);
      font-family: 'Manrope', sans-serif;
      color: var(--text-main);
    }

    /* èƒŒæ™¯ Canvas */
    #vis-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: -1;
    }

    /* --- UI æ ·å¼ --- */
    .overlay {
      position: relative;
      width: 100%;
      height: 100%;
      /* å‚ç›´å±…ä¸­ï¼Œæ°´å¹³é å·¦ (ç¬¦åˆæˆªå›¾æ’ç‰ˆ) */
      padding: 0 clamp(2rem, 8vw, 6rem); 
      display: flex;
      flex-direction: column;
      justify-content: center; 
      align-items: flex-start;
      pointer-events: none; /* è®©é¼ æ ‡ç©¿é€å»æ“ä½œ 3D */
    }

    .content-card {
      max-width: 800px;
      /* æ·±è‰²ç»ç’ƒæ‹Ÿæ€ */
      background: linear-gradient(135deg, rgba(10, 10, 10, 0.6), rgba(0, 0, 0, 0.9));
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.7);
      border-radius: 1.5rem;
      padding: clamp(2rem, 5vw, 3rem);
      backdrop-filter: blur(24px);
      pointer-events: auto; /* å¡ç‰‡å†…çš„æ–‡å­—å¯é€‰ä¸­ */
    }

    /* é¡¶éƒ¨èƒ¶å›Šæ ‡ç­¾ */
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 0.6rem;
      padding: 0.4rem 1rem;
      border-radius: 100px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.1);
      font-size: 0.75rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #cbd5e1;
      margin-bottom: 1.5rem;
    }

    .pill-dot {
      width: 0.5rem;
      height: 0.5rem;
      border-radius: 50%;
      background: #38bdf8;
      box-shadow: 0 0 10px #38bdf8;
    }

    /* ä¸»æ ‡é¢˜ */
    h1 {
      font-size: clamp(3rem, 6vw, 4.5rem);
      font-weight: 800;
      line-height: 1.0;
      letter-spacing: -0.03em;
      margin-bottom: 1rem;
      color: white;
    }

    /* æ ‡é¢˜æ¸å˜è‰² (Imaginâˆ Lab) */
    .brand-purple {
      color: #a855f7; /* ç´«è‰² */
    }
    .brand-blue {
      color: #38bdf8; /* è“è‰² */
    }
    
    /* å‰¯æ ‡é¢˜ */
    .subtitle {
      font-size: 0.85rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      color: var(--text-muted);
      margin-bottom: 2rem;
      opacity: 0.8;
    }

    /* æ­£æ–‡ */
    p {
      font-size: 1.1rem;
      line-height: 1.7;
      color: #d1d5db; /* æµ…ç° */
      margin-bottom: 1.2rem;
      max-width: 680px;
      font-weight: 400;
    }
    
    /* å¼ºè°ƒæ–‡å­— */
    p.intro {
      font-weight: 500;
      color: #f3f4f6; /* äº®ç™½ */
    }

    /* åº•éƒ¨è¾…åŠ©æ–‡å­— */
    .footer-note {
      margin-top: 1rem;
      font-size: 0.8rem;
      color: rgba(255, 255, 255, 0.3);
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    @media (max-width: 768px) {
      .overlay { padding: 1.5rem; align-items: stretch; }
      .content-card { padding: 1.5rem; }
      h1 { font-size: 2.5rem; }
    }
  </style>
</head>

<body>

  <div id="vis-container"></div>

  <div class="overlay">
    <div class="content-card">
      <div class="pill">
        <span class="pill-dot"></span>
        <span>IMAGINâˆ LAB Â· LAUNCHING 2026</span>
      </div>

      <h1>
        Imagin<span class="brand-purple">âˆ</span> <span class="brand-blue">Lab</span>
      </h1>
      
      <div class="subtitle">Frontier research for the next era of intelligence</div>

      <p class="intro">
        I will launch Imaginâˆ Lab in 2026 â€” a frontier research lab decoding the principles of biological intelligence to build the next generation of AI.
      </p>
      <p>
        We pioneer neuro-inspired architectures and immersive interfaces that augment human capability and expand the boundaries of imagination.
      </p>

    </div>
  </div>

  <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

        // é…ç½®
        const MODEL_PATH = './whole_brain_source.glb'; 
        const SAMPLING_RATE = 8;
        console.log("ğŸš€ Imaginâˆ Lab initialized");

        // åœºæ™¯æ­å»º
        const container = document.getElementById('vis-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.03); 
        const clock = new THREE.Clock();

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 20);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setClearColor(0x000000, 1);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enableZoom = false;   
        controls.autoRotate = false;
        controls.target.set(0, 0, 0);

        // ç²’å­è´´å›¾
        function createCircleTexture() {
            const size = 64;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');
            const center = size / 2;
            context.beginPath();
            context.arc(center, center, size/2, 0, 2 * Math.PI);
            context.fillStyle = '#ffffff'; 
            context.fill();
            return new THREE.CanvasTexture(canvas);
        }
        const circleSprite = createCircleTexture();
        const uniforms = { uTime: { value: 0 } };

        // åŠ è½½æ¨¡å‹
        const loader = new GLTFLoader();
        let brainParticles = null;

        loader.load(MODEL_PATH, 
            (gltf) => {
                const originalScene = gltf.scene;
                const particlesGeometry = new THREE.Group();

                originalScene.traverse((child) => {
                    if (child.isMesh) {
                        const originalGeo = child.geometry;
                        const originalPositions = originalGeo.attributes.position.array;
                        const totalCount = originalPositions.length / 3;
                        const positionsList = [];
                        const colorsList = [];
                        const phasesList = []; 
                        const colorObj = new THREE.Color();

                        for (let i = 0; i < totalCount; i += SAMPLING_RATE) {
                            const x = originalPositions[i * 3];
                            const y = originalPositions[i * 3 + 1];
                            const z = originalPositions[i * 3 + 2];
                            positionsList.push(x, y, z);
                            phasesList.push(Math.random() * Math.PI * 2);
                            colorObj.setHSL(0.6, 0.8, 0.3); // æ·±è“/é’è‰²
                            colorsList.push(colorObj.r, colorObj.g, colorObj.b);
                        }

                        const sparseGeometry = new THREE.BufferGeometry();
                        sparseGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positionsList, 3));
                        sparseGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colorsList, 3));
                        sparseGeometry.setAttribute('phase', new THREE.Float32BufferAttribute(phasesList, 1));

                        const material = new THREE.PointsMaterial({
                            size: 0.12, 
                            map: circleSprite, 
                            vertexColors: true,
                            transparent: true,
                            opacity: 1.0, 
                            depthWrite: false, 
                            blending: THREE.AdditiveBlending, 
                        });

                        // --- Shader ä¿®å¤ä¸å¾®å…‰æ•ˆæœ ---
                        material.onBeforeCompile = (shader) => {
                            shader.uniforms.uTime = uniforms.uTime;

                            // 1. å£°æ˜ Phase
                            shader.vertexShader = shader.vertexShader.replace(
                                '#include <common>',
                                `#include <common>
                                attribute float phase;
                                varying float vPhase;`
                            );

                            // 2. ä¼ é€’ Phase (åœ¨ begin_vertex)
                            shader.vertexShader = shader.vertexShader.replace(
                                '#include <begin_vertex>',
                                `#include <begin_vertex>
                                vPhase = phase;`
                            );
                            
                            // 3. è®¡ç®—å¤§å°è¡°å‡ (åœ¨ fog_vertex - å®‰å…¨ä½ç½®)
                            shader.vertexShader = shader.vertexShader.replace(
                                '#include <fog_vertex>',
                                `#include <fog_vertex>
                                float dist = length(mvPosition.xyz); 
                                float sizeBoost = smoothstep(20.0, 0.0, dist) * 1.5 + 1.0; 
                                gl_PointSize *= sizeBoost;`
                            );

                            // 4. ç‰‡å…ƒç€è‰²å™¨å¾®å…‰
                            shader.fragmentShader = shader.fragmentShader.replace(
                                '#include <common>',
                                `#include <common>
                                uniform float uTime;
                                varying float vPhase;`
                            );
                            shader.fragmentShader = shader.fragmentShader.replace(
                                '#include <map_particle_fragment>',
                                `#include <map_particle_fragment>
                                float glimmer = sin(uTime * 1.5 + vPhase) * 0.5 + 0.5;
                                glimmer = mix(0.2, 1.0, glimmer);
                                diffuseColor.a *= glimmer;`
                            );
                        };

                        const points = new THREE.Points(sparseGeometry, material);
                        points.scale.set(1.2, 1.2, 1.2); 
                        points.position.set(0, -1, 0); 
                        particlesGeometry.add(points);
                    }
                });

                brainParticles = particlesGeometry;
                scene.add(brainParticles);
            },
            undefined,
            (error) => {
                console.error("âŒ Error loading model (Check path/file):", error);
            }
        );

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            uniforms.uTime.value = time;
            controls.update(); 

            if (brainParticles) {
                brainParticles.rotation.y += 0.0005; 
            }
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });
  </script>
</body>
</html>