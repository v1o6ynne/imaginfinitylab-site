<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Imaginâˆž Lab - Debug Mode</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/examples/jsm/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <style>
    :root { --bg-color: #000000; --text-main: #e5e7eb; }
    body { margin: 0; background-color: var(--bg-color); color: var(--text-main); font-family: 'Manrope', sans-serif; overflow: hidden; }
    #vis-container { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: -1; }
    
    /* Simple styling for the overlay text so you can see it */
    .overlay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; text-align: center; pointer-events: none; }
    h1 { font-size: 3rem; margin-bottom: 0.5rem; }
  </style>
</head>

<body>
  <div id="vis-container"></div>
  
  <div class="overlay">
    <h1>Imaginâˆž Lab</h1>
    <p>Debug Mode: Check Console (F12) if model missing</p>
  </div>

  <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

        console.log("ðŸš€ Three.js starting...");

        const MODEL_PATH = './whole_brain_source.glb'; 
        const SAMPLING_RATE = 8;

        const container = document.getElementById('vis-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.03); 
        const clock = new THREE.Clock();

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 20);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setClearColor(0x000000, 1);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
        container.appendChild(renderer.domElement);

        // Debug Axes: Red=X, Green=Y, Blue=Z
        const axesHelper = new THREE.AxesHelper( 5 );
        scene.add( axesHelper );

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Texture
        function createCircleTexture() {
            const size = 64;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');
            const center = size / 2;
            context.beginPath();
            context.arc(center, center, size/2, 0, 2 * Math.PI);
            context.fillStyle = '#ffffff'; 
            context.fill();
            return new THREE.CanvasTexture(canvas);
        }
        const circleSprite = createCircleTexture();
        const uniforms = { uTime: { value: 0 } };

        // Loader
        const loader = new GLTFLoader();
        let brainParticles = null;

        loader.load(MODEL_PATH, 
            (gltf) => {
                console.log("ðŸŽ‰ Model Loaded", gltf);
                const originalScene = gltf.scene;
                const particlesGeometry = new THREE.Group();

                originalScene.traverse((child) => {
                    if (child.isMesh) {
                        const originalGeo = child.geometry;
                        const originalPositions = originalGeo.attributes.position.array;
                        const totalCount = originalPositions.length / 3;
                        const positionsList = [];
                        const colorsList = [];
                        const phasesList = []; 
                        const colorObj = new THREE.Color();

                        for (let i = 0; i < totalCount; i += SAMPLING_RATE) {
                            const x = originalPositions[i * 3];
                            const y = originalPositions[i * 3 + 1];
                            const z = originalPositions[i * 3 + 2];
                            positionsList.push(x, y, z);
                            phasesList.push(Math.random() * Math.PI * 2);
                            colorObj.setHSL(0.6, 0.8, 0.3); 
                            colorsList.push(colorObj.r, colorObj.g, colorObj.b);
                        }

                        const sparseGeometry = new THREE.BufferGeometry();
                        sparseGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positionsList, 3));
                        sparseGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colorsList, 3));
                        sparseGeometry.setAttribute('phase', new THREE.Float32BufferAttribute(phasesList, 1));

                        const material = new THREE.PointsMaterial({
                            size: 0.12, 
                            map: circleSprite, 
                            vertexColors: true,
                            transparent: true,
                            opacity: 1.0, 
                            depthWrite: false, 
                            blending: THREE.AdditiveBlending, 
                        });

                        // Corrected Shader Injection
                        material.onBeforeCompile = (shader) => {
                        shader.uniforms.uTime = uniforms.uTime;

                        // --- Vertex Shader ---
                        
                        // 1. Declare custom attribute and varying
                        shader.vertexShader = shader.vertexShader.replace(
                            '#include <common>',
                            `
                            #include <common>
                            attribute float phase;
                            varying float vPhase;
                            `
                        );

                        // 2. Assign varying (runs early)
                        shader.vertexShader = shader.vertexShader.replace(
                            '#include <begin_vertex>',
                            `
                            #include <begin_vertex>
                            vPhase = phase;
                            `
                        );

                        // 3. Calculate Size Boost (runs LATE, after mvPosition is calculated)
                        shader.vertexShader = shader.vertexShader.replace(
                            '#include <fog_vertex>',
                            `
                            #include <fog_vertex>
                            // mvPosition is calculated in <project_vertex>, so it is available here
                            float dist = length(mvPosition.xyz); 
                            float sizeBoost = smoothstep(20.0, 0.0, dist) * 1.5 + 1.0;
                            gl_PointSize *= sizeBoost;
                            `
                        );

                        // --- Fragment Shader ---
                        
                        shader.fragmentShader = shader.fragmentShader.replace(
                            '#include <common>',
                            `
                            #include <common>
                            uniform float uTime;
                            varying float vPhase;
                            `
                        );

                        shader.fragmentShader = shader.fragmentShader.replace(
                            '#include <map_particle_fragment>',
                            `
                            #include <map_particle_fragment>
                            float glimmer = sin(uTime * 1.5 + vPhase) * 0.5 + 0.5;
                            glimmer = mix(0.2, 1.0, glimmer);
                            diffuseColor.a *= glimmer;
                            `
                        );
                    };

                        const points = new THREE.Points(sparseGeometry, material);
                        points.scale.set(1.2, 1.2, 1.2); 
                        points.position.set(0, -1, 0); 
                        particlesGeometry.add(points);
                    }
                });
                brainParticles = particlesGeometry;
                scene.add(brainParticles);
            }, 
            (xhr) => { console.log(`Loading: ${(xhr.loaded / xhr.total * 100)}%`); },
            (error) => {
                console.error('âŒ Error loading model:', error);
                // Fallback Cube
                const geometry = new THREE.BoxGeometry(5,5,5);
                const material = new THREE.MeshBasicMaterial({color: 0xff0000, wireframe: true});
                scene.add(new THREE.Mesh(geometry, material));
            }
        );

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            uniforms.uTime.value = time;
            controls.update(); 
            if (brainParticles) brainParticles.rotation.y += 0.0005;
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });
  </script>
</body>
</html>
